\documentclass[addpoints]{exam}

\newenvironment{palatino}{\fontfamily{ppl}\selectfont}{\par}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}% Include figure files
\usepackage{comment}
\usepackage{multicol}
\usepackage{placeins}
\usepackage{amsmath,amssymb,amsthm,mathrsfs,amsfonts,dsfont} 
\usepackage[colorlinks=true]{hyperref}
%
\addtolength{\topmargin}{-1cm}
	\addtolength{\textheight}{2cm}
	\pagestyle{empty}
\begin{document}
\begin{palatino}

%\maketitle
%\pagenumbering{gobble}
\noindent Corso di python novembre-dicembre 2020 - ISM \\
\noindent Fulvio Paleari -- fulvio.paleari@mlib.ism.cnr

\hrulefill
%\centering
\vspace{0.2in}\\
\setlength{\parindent}{0pt}

\textbf{1. Introduzione a python} \\

a. \quad Utilizzando \texttt{numpy}, generate una matrice $3\times 3$ contentente elementi casuali compresi fra $-1$ e $1$ e trovatene il determinante utilizzando la regola di Sarruss. Fate una funzione per generare la matrice e un'altra per il calcolo del determinante. Controllate il risultato utilizzando il metodo di \texttt{numpy} per trovare il determinante di una matrice.

\hphantom{ciao}

b. Considerando la matrice $3\times 3$ costruita precedentemente, calcolatene autovalori e autovettori con gli opportuni metodi \texttt{numpy}, dopodiché visualizzatene lo spettro usando \texttt{matplotlib.pyplot} secondo la seguente formula:
\begin{equation*}
	S(\omega)= \mathrm{Im}\left\{\sum_{i=1}^3 \frac{|\mathbf{e}_i|^2}{\omega-E_i-\mathrm{i}\eta} \right\},
\end{equation*} 
dove $\mathbf{e}_i$ è un autovettore e $E_i$ il corrispondente autovalore della matrice $3\times 3$, mentre $\eta>0$ rappresenta un parametro di \textit{linewidth} (molto piccolo rispetto alla scala di $\omega$ considerata) introdotto \textit{ad hoc}.

\hphantom{ciao}

c. \quad La sequenza di Fibonacci è definita dalla seguente relazione ricorsiva:

\begin{equation*}
	F_n = F_{n-1}+F_{n-2} \qquad \mathrm{con} \ F_1 = 1 \ e \ F_2 = 1.
\end{equation*}

Quindi i primi $12$ termini saranno:

\begin{equation*}
	F_1 = 1, \
	F_2 = 1, \
	F_3 = 2, \
	F_4 = 3, \
	F_5 = 5, \
	F_6 = 8, \
	F_7 = 13, \
	F_8 = 21, \
	F_9 = 34, \
	F_{10} = 55, \
	F_{11} = 89, \
	F_{12} = 144.
\end{equation*}

Il dodicesimo termine, $F_{12}$, è il primo termine formato da tre cifre.

Qual è l'indice del primo termine della sequenza di Fibonacci formato da $10$ cifre? 
Potete usare funzioni, cicli \texttt{for}, \texttt{if} e \texttt{numpy} array.

\hphantom{ciao}

[Questa è una versione del problema $25$ di \href{https://projecteuler.net/problem=25}{Project Euler}]

\hphantom{ciao}
 
d. \quad Utilizzate \texttt{numpy.loadtxt} per caricare il file \texttt{testo.dat} (fornendo il corretto \textit{keyword argument} per far funzionare \texttt{loadtxt} con caratteri invece che con numeri). A questo punto, costruite una funzione che conti quante vocali sono presenti nel testo, sia in totale ($N_{tot}$), sia per singola vocale ($N_a$, $N_e$, $N_i$, ...). Rappresentate i risultati (es. $N_a/N_{tot}$,...) in un istogramma.

\hphantom{ciao}
	
\textbf{3. Visualizzazione dati} \\

\hphantom{ciao}

a. Costruite una funzione $y=\mathrm{sin}(s_i*\varphi)$ nel dominio $\varphi \in [0,2\pi]$ dove gli $s_i$ sono i fattori di scala seguenti: $s=\{1,2,3,4,5\}$. Fate il plot della funzione al variare dei fattori di scala, e personalizzatelo definendo limiti, nomi e valori degli assi, colori, tipi di linea, etc.
Ripetete l'esercizio, ma questa volta facendo i plot in coordinate polari utilizzando le opzioni messe a disposizione da \texttt{pyplot}. 

\hphantom{ciao}

b. \quad Fate il plot di una distribuzione gaussiana normalizzata $G(x;\mu,\sigma)$ con media $\mu=3$ e deviazione standard $\sigma=0.25$. Usate \texttt{numpy} o \texttt{scipy} oppure costruite una vostra funzione.
Valutate il punto $x$ in cui l'integrale a partire da $-\infty$ è pari a $0.7$, cioè:
\begin{equation*}
	x \ \mathrm{t.c.} \ \int_{-\infty}^x \mathrm{d}x^\prime \ G(x^\prime; \mu,\sigma)=0.7,
\end{equation*}
e colorate l'area corrispondente.

\hphantom{ciao}

[Esercizio preso dalle lezioni di python tenute all'Università di Milano-Bicocca da Matteo Bonetti]

\hphantom{ciao}

\textbf{4. Analisi dati} \\

\hphantom{ciao}

a. \quad Il governo pubblica quotidianamente i dati relativi all'andamento nazionale dell'epidemia da COVID-19 in un repository github pubblicamente accessibile. I dati sono in formato \texttt{csv} e sono accessibili a \href{https://github.com/pcm-dpc/COVID-19/blob/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv}{questo indirizzo}. 

Scaricate il database \texttt{dpc-covid19-ita-andamento-nazione.csv} dal sito (potete cliccare sul tasto \texttt{Raw}, che vi porta ad una pagina web contenente unicamente i dati non formattati, copiarne l'indirizzo e da terminale digitare \texttt{wget indirizzo/pagina/web} per ottenere il database).

A questo punto, aprite il database in python utilizzando \texttt{pandas}, e producete un plot dell'andamento della variabile \texttt{totale\_positivi} dal 24 febbraio (data di inizio presa dati) ad oggi. 

Se volete, sperimentate con \texttt{pandas} e \texttt{pyplot} per ottenere altri plot ed abbozzare un'analisi dei dati.

\hphantom{ciao}

b. Supponiamo di aver fatto delle misure in funzione del tempo per un certo fenomeno, e supponiamo di sapere che la legge fisica che governa questo fenomeno è quella di un oscillatore smorzato:
\begin{equation*}
	F(t)=I_0 \mathrm{e}^{-\gamma t} \mathrm{cos}(\Omega t +\varphi)+ C
\end{equation*}

Considerate il file \texttt{damped\_osc\_low\_noise.dat}. Questo contiene due colonne: la prima è il tempo, la seconda il valore di $F(t)$ misurato sperimentalmente. Caricatelo con \texttt{numpy.loadtxt} ed eseguite -- utilizzando \texttt{scipy} -- il fit dei dati secondo la funzione indicata. Stimate i valori del fattore di smorzamento $\gamma$ e della frequenza di risonanza $\Omega$ e fate un plot dei risultati sperimentali e del fit.

Considerate ora i file \texttt{damped\_osc\_high\_noise.dat} e \texttt{damped\_osc\_very\_high\_noise.dat}. Questi contengono misurazioni relative allo stesso esperimento, ma i dati sono sensibilmente più rumorosi. Ripetete la procedura di fit anche per questi dati (magari importando tutti i file \texttt{*.dat} utilizzando \texttt{glob}) e fate un plot delle varie stime di $\Omega$ e $\gamma$. Provate a estrapolare il valore reale di queste grandezze.

\hphantom{ciao}

\textbf{5. Programmazione orientata ad oggetti}

\hphantom{ciao}

a. \quad È possibile stimare il valore di $\pi$ attraverso una simulazione MonteCarlo.
Per farlo si campiona l'area di un quadrato di lato uguale a 2, ovvero si estraggono attraverso un generatore di numeri random coppie $(x,y)$ di numeri nell'intervallo $[-1,1]$.
Per ogni coppia estratta si controlla se il punto è interno a un cerchio di raggio $1$, ovvero si verifica che $x^2+y^2 <= 1$. 
Il rapporto fra il numero di punti interni al cerchio e il numero totale di punti tende al valore $\pi/4$ al crescere del numero di campionamenti.

\hphantom{ciao}

Realizzate una classe python che gestisca questa simulazione. 
La classe richiede il numero di campionamenti come parametro da passare al costruttore (metodo \texttt{\_\_init\_\_}) e definisce un metodo \texttt{run} che esegue la simulazione. 
Oltre al valore finale il metodo deve produrre il plot di convergenza, ovvero il plot del valore del rapporto durante la simulazione. 
A questo scopo è necessario definire come membro della classe una lista, o un array \texttt{numpy}, che contenga i valori del rapporto punti interni / punti totali durante la simulazione.

\hphantom{ciao}

[Esercizio proposto da Marco D'Alessandro]

\FloatBarrier

\end{palatino}
\end{document}